<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"> 
  <title>7.9将中横线字符串转换成驼峰拼写法</title>  
</head>
<body>
  <!-- 
      String对象的replace()方法是一个强大且灵活的方法。
      将正则表达式作为replace()方法的第一个参数时， 
      导致在该模式的匹配元素（全局匹配的话，就是多个全局匹配）上进行替换，
      而不是在固定字符串上进行替换。
      举个例子，若需让所有大写字母字符串都替换成“X”，可以这样写：
      "ABCDEfg".replace(/[A-Z]/g, "X"), 其结果为 "XXXXXfg"
      replace()最强大的特性是可以接受一个函数作为替换值，而不是固定的字符串。
      当替换值（第二个参数）是一个函数时，每个匹配都会调用该函数
      （记住，全局搜索会在源字符串中匹配所有的模式实例）并带有一串参数列表。

      1. 匹配的完整文本
      2. 匹配的捕获一个捕获对应一个参数
      3. 匹配字符串在源字符串中的索引
      4. 源字符串

      函数的返回值是即将要替换的值
      这给了我们很多思考的余地，让我们在运行时确定应该替换的字符串，
      并掌握大量与匹配特征有关的信息

      例如在如下代码清单中，我们使用一个函数，
      动态地将中横线分隔的字符转换成等价的驼峰拼写字符
   -->

  <script src="../js/assert.js"></script>
  <script>
    // 转换成大写字母
    function upper(all, letter) {      
      return letter.toUpperCase();
    }

    assert(
      "border-bottom-width".replace(/-(\w)/g, upper) == "borderBottomWidth",
      "Camel cased a hyphenated string."
    );

    /**
     * 在这里，我们提供了一个正则表达式，用于匹配中横线字符后的任意一个字符。
     * 全局正则中的捕获结果就是该匹配的字符 (不包括中横线) 
     * 函数在每次被调用的时候 (本例中是两次) 传入完整的字符串作为一个参数，
     * 捕获结果 (本例只有一个) 作为第二个参数。 我们对其他参数不感兴趣，所以没指定他们。
     *
     * 函数在第一次被调用的时候，传入了"-b" 和 "b", 第二次被调用的时候传入的是"-w"和"w",
     * 在本例中，将捕获字符串转换成大写，并作为替换值返回。
     * 最终，我们将"-b"替换成了"B", 将"-w"替换成了"W"。
     *
     * 由于正则在每一次成功匹配的时候都会调用这样的替换函数。这种技术甚至可以超越简单的机械替换，
     * 并且可以作为字符串遍历的一种手段，而不用像本章前面看到的那样，在while循环执行exec()方法
     *
     * 
     */
  </script>
</body>
</html>