> 到了第2篇，这一部分主要是集合collection，详细请参考官方文档，[1.8.3中文文档](http://www.css88.com/doc/underscore/#) 结合这个来理解更快些


## 集合函数 170 - 486行

underscore扩展了很多原生JS拥有的方法，有很多优秀地设计思想值得我们学习和探究。我们在用的过程中，了解到底层的实现更有利于我们将来的选择及性能优化

### each

`下环线`的each方法遍历所传obj（这里可看作一个列表，数组或类数组）中的所有元素，按顺序用遍历输出每个元素。如果传递了context参数，则把iteratee绑定到context对象上。每次调用iteratee都会传递三个参数：(element, index, list)。如果list是个JavaScript对象，iteratee的参数是 (value, key, list))。返回list以方便链式调用。

```js
_.each = _.forEach = function(obj, iteratee, context) {
  iteratee = optimizeCb(iteratee, context);
  var i, length;
  if (isArrayLike(obj)) {
    for (i = 0, length = obj.length; i < length; i++) {
      iteratee(obj[i], i, obj);
    }
  } else {
    var keys = _.keys(obj);
    for (i = 0, length = keys.length; i < length; i++) {
      iteratee(obj[keys[i]], keys[i], obj);
    }
  }
  return obj;
};
```

```js
_.each([1, 2, 3], i => console.log(i));  
// 1, 2, 3  注，返回的是每个迭代对象自身
```

之前的optimizeCb是一个重载函数，让传入的func能绑定到当前自己的作用域上，接着就是遍历列表中的元素了，在流程控制中加入isArrayLike辅助函数来检测数组。若不是数组当作对象来遍历

### map

通过转换函数(iteratee迭代器)映射列表中的每个值产生价值的新数组。该方法接收三个参数，循环对象，迭代器和环境参数。后两个参数作为活动对象传到了cb方法中。

```js
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };
```

```js
_.map([1,2,3], num => num * 2);
// [2,4,6] 注：返回的是results这是一个数组
_.map({name: 'fri', age: 24}, (k, v) => `${k}: ${v}`);
// ["fri: name", "24: age"] map一个对象，返回的是由key,val组成的数组
```

* keys, length, results这三个变量的声明很精髓，(后面也有很多地方用到) !有隐式转换变为布尔型，所以keys = `布尔` && _.keys(obj) 因为逻辑与，表达式成立的条件是，前面部分会为真，即这句直接拿到了 _.key(obj)。
* 数组中才有length这一属性，普通对象中是没有定义的
* Array(length)会创建一个长度为length的数组这么再来看循环体中的results[index]就清楚多了

### reduce reduceRight

reduce方法把list中元素归结为一个单独的数值。
Memo是reduce函数的初始值，reduce的每一步都需要由iteratee返回。这个迭代传递4个参数：memo,value 和 迭代的index（或者 key）和最后一个引用的整个 list。

```js
  var createReduce = function(dir) {
    var reducer = function(obj, iteratee, memo, initial) {
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      if (!initial) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    };

    return function(obj, iteratee, memo, context) {
      var initial = arguments.length >= 3;
      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
    };
  };

  _.reduce = _.foldl = _.inject = createReduce(1);

  _.reduceRight = _.foldr = createReduce(-1);
```

```js
_.reduce([1,2,3], (memo, num) => memo + num)
// 6  这里只传了memo和num, 因为传入的是数组initial默认为0
```

如果没有memo传递给reduce的初始调用，iteratee不会被列表中的第一个元素调用。第一个元素将取代 传递给列表中下一个元素调用iteratee的memo参数。

最外层的匿名函数中的dir传到了 `index = dir > 0 ? 0 : length - 1 ` 由dir来判断是reduce还是reduceRight，这里高度抽象的思想值得我们学习

createReduce是`下划线`作用域中的私有变量，外部访问不到，这里 _.reduce 是向外暴露的接口，我们调用的api 其实是调用craeteReduce()所返回的函数

### find

keyFinder的结果由传入obj是数组(下标)还是对象(key)决定，这里的key是一个递归调用。在obj中逐项查找，返回第一个通过predicate迭代函数真值检测的元素值，如果没有值传递给测试迭代器将返回undefined。 如果找到匹配的元素，函数将立即返回，不会遍历整个list。

```js
  _.find = _.detect = function(obj, predicate, context) {
    // _.findIndex() 652行
    // _.findKey() 1093行
    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
  };

```

```js
_.find([2,4,5,6,7,8], num => num % 2 != 0)
// 5， 找到5就不会继续找7了
```

### filter

遍历list中的每个值，返回包含所有通过predicate真值检测的元素值。（如果存在原生filter方法，则用原生的filter方法。）

```js
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };
```

```js
_.filter([2,3,4,6,8,10], num => num % 2 === 0)
// [2,4,6,8,10] 3被过滤掉
_.filter([{name:'fri'},{name: 'yk'}, {name: 'hhh'}], item => item['name'] == 'fri')
// [{name: 'fri'}]
```