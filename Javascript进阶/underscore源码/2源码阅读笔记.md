> 这一篇到了源码170行以后，主要是`underscore(下文用下划线代替- -)`向外暴露的一些核心API， `_` 扩展了很多原生JS拥有的方法，有很多优秀地设计思想值得我们学习和探究。我们在用的过程中，了解到底层的实现更有利于我们将来的选择及性能优化

<!-- more -->

## 集合函数 170 - 486行


### each  

_.each(obj, iteratee, [context]) 

`_` 的each方法遍历所传obj（这里可看作一个列表，数组或类数组）中的所有元素，按顺序用遍历输出每个元素。如果传递了context参数，则把iteratee绑定到context对象上。每次调用iteratee都会传递三个参数：(element, index, list)。如果list是个JavaScript对象，iteratee的参数是 (value, key, list))。返回list以方便链式调用。

```js
_.each = _.forEach = function(obj, iteratee, context) {
  iteratee = optimizeCb(iteratee, context);
  var i, length;
  if (isArrayLike(obj)) {
    for (i = 0, length = obj.length; i < length; i++) {
      iteratee(obj[i], i, obj);
    }
  } else {
    var keys = _.keys(obj);
    for (i = 0, length = keys.length; i < length; i++) {
      iteratee(obj[keys[i]], keys[i], obj);
    }
  }
  return obj;
};
```

```js
_.each([1, 2, 3], i => console.log(i));  
=> 1, 2, 3  注，返回的是每个迭代对象自身
_.each({a: '1', b: [1,2,3], c:{name: 'fri'}}, item => console.log(item))
=> 1, [1,2,3], {name: 'fri'}  注：返回的是迭代对象的每一项，拿到的是value值
```

`iteratee = optimizeCb(iteratee, context)形成一个递归调用`，if分支用于控制是迭代数组还是对象，最后返回的是迭代的自身。

### map

_.map(obj, iteratee, [context]) 

通过转换函数(iteratee迭代器)映射列表中的每个值产生价值的新数组。该方法接收三个参数，循环对象，迭代器和环境参数。后两个参数作为活动对象传到了cb方法中。

```js
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };
```

```js
_.map([1,2,3], num => num * 2);
=> [2,4,6] 注：返回的是results这是一个数组

_.map({name: 'fri', age: 24}, (k, v) => `${k}: ${v}`);
=> ["fri: name", "24: age"] map一个对象，返回的是由key,val组成的数组
```

* keys, length, results这三个变量的声明很精髓，(后面也有很多地方用到) !有隐式转换变为布尔型，所以keys = `布尔` && _.keys(obj) 因为逻辑与，表达式成立的条件是，前面部分会为真，即这句直接拿到了 _.key(obj)。
* 数组中才有length这一属性，普通对象中是没有定义的
* Array(length)会创建一个长度为length的数组这么再来看循环体中的results[index]就清楚多了

### reduce reduceRight

_.reduce(list, iteratee, [memo], [context]) 
_.reduceRight(list, iteratee, memo, [context])

reduce方法把list中元素归结为一个单独的数值。
Memo是reduce函数的初始值，reduce的每一步都需要由iteratee返回。这个迭代传递4个参数：memo,value 和 迭代的index（或者 key）和最后一个引用的整个 list。

```js
  var createReduce = function(dir) {
    var reducer = function(obj, iteratee, memo, initial) {
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      if (!initial) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    };

    return function(obj, iteratee, memo, context) {
      var initial = arguments.length >= 3;
      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
    };
  };

  _.reduce = _.foldl = _.inject = createReduce(1);

  _.reduceRight = _.foldr = createReduce(-1);
```

```js
_.reduce([1,2,3], (memo, num) => memo + num)
=> 6  这里只传了memo和num, 因为传入的是数组initial默认为0
```

如果没有memo传递给reduce的初始调用，iteratee不会被列表中的第一个元素调用。第一个元素将取代 传递给列表中下一个元素调用iteratee的memo参数。

最外层的匿名函数中的dir传到了 `index = dir > 0 ? 0 : length - 1 ` 由dir来判断是reduce还是reduceRight，这里高度抽象的思想值得我们学习

createReduce是 `_` 作用域中的私有变量，外部访问不到，这里 _.reduce 是向外暴露的接口，我们调用的api 其实是调用craeteReduce()所返回的函数

### find

_.find(obj, predicate, [context]) 

keyFinder的结果由传入obj是数组(下标)还是对象(key)决定，这里的key是一个递归调用。在obj中逐项查找，返回第一个通过predicate迭代函数真值检测的元素值，如果没有值传递给测试迭代器将返回undefined。 如果找到匹配的元素，函数将立即返回，不会遍历整个list。

```js
  _.find = _.detect = function(obj, predicate, context) {
    // _.findIndex() 652行
    // _.findKey() 1093行
    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
  };

```

```js
_.find([2,4,5,6,7,8], num => num % 2 != 0)
=> 5， 找到5就不会继续找7了
```

### filter

_.filter(obj, predicate, [context]) 

遍历所传obj中的每个值，返回包含所有通过predicate真值检测的元素值。（如果存在原生filter方法，则用原生的filter方法。）

```js
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };
```

```js
_.filter([2,3,4,6,8,10], num => num % 2 === 0)
=> [2,4,6,8,10] 3被过滤掉
_.filter([{name:'fri'},{name: 'yk'}, {name: 'hhh'}], item => item['name'] == 'fri')
=> [{name: 'fri'}]
```

这里额外说两句，其实暴露的API写法大同小异，主要是理解核心方法中的 `cb` `optimizeCb` 知道 `_` 是怎么通过高阶函数传参，拿到传入对象（函数）的作用域 `func.apply(context, arguments);`

### reject

_.reject(list, predicate, [context]) 返回list中没有通过predicate真值检测的元素集合，与filter相反

```js
_.reject = function(obj, predicate, context) {
  return _.filter(obj, _.negate(cb(predicate)), context);
};
```

对_.filter的一个封装， `_.negate(916行)`可见到，返回的是结果为false的集合

### every 

_.every(obj, [predicate], [context])  如果list中的所有元素都通过predicate的真值检测就返回true。

```js
_.every = _.all = function(obj, predicate, context) {
  predicate = cb(predicate, context);
  var keys = !isArrayLike(obj) && _.keys(obj),
      length = (keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = keys ? keys[index] : index;
    if (!predicate(obj[currentKey], currentKey, obj)) return false;
  }
  return true;
};
```

```js
_.every([false, 0, null, undefined, NaN, 1], item => item != true) 
=> true
```


### some

_.some(obj, [predicate], [context])  如果obj中有任何一个元素通过 predicate 的真值检测就返回true。一旦找到了符合条件的元素, 就直接中断对obj的遍历. 

```js
_.some = _.any = function(obj, predicate, context) {
  predicate = cb(predicate, context);
  var keys = !isArrayLike(obj) && _.keys(obj),
      length = (keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = keys ? keys[index] : index;
    if (predicate(obj[currentKey], currentKey, obj)) return true;
  }
  return false;
};
```

```js
_.some([false, 0, null, undefined, NaN, 1], item => item == true) 
=> true
```

### contains

_.contains(obj, value, [fromIndex])  如果obj包含指定的value则返回true。如果obj 是数组，内部使用indexOf判断。使用fromIndex来给定开始检索的索引位置。这个方法ES6已有实现 参考`Array.prototype.includes`

```js
_.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
  if (!isArrayLike(obj)) obj = _.values(obj);
  if (typeof fromIndex != 'number' || guard) fromIndex = 0;
  return _.indexOf(obj, item, fromIndex) >= 0;
};
```

```js
_.contains([a,b,c], 3)
=> true
```

### invoke 

_.invoke(list, methodName, *arguments) 在list的每个元素上执行methodName方法。 任何传递给invoke的额外参数，invoke都会在调用methodName方法的时候传递给它

```js
_.invoke = restArgs(function(obj, path, args) {
  var contextPath, func;
  if (_.isFunction(path)) {
    func = path;
  } else if (_.isArray(path)) {
    contextPath = path.slice(0, -1);
    path = path[path.length - 1];
  }
  return _.map(obj, function(context) {
    var method = func;
    if (!method) {
      if (contextPath && contextPath.length) {
        context = deepGet(context, contextPath);
      }
      if (context == null) return void 0;
      method = context[path];
    }
    return method == null ? method : method.apply(context, args);
  });
});
```

```js
_.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
=> [[1, 5, 7], [1, 2, 3]]
```

### pluck

_.pluck(list, propertyName)  萃取数组对象中某属性值，返回一个数组

```js
_.pluck = function(obj, key) {
  return _.map(obj, _.property(key));
};
```

```js
var stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];
_.pluck(stooges, 'name');
=> ["moe", "larry", "curly"]
```

这是对 _.map用法的一个封装

### where、findWhere

_.where(obj, attrs) 遍历obj中的每一个值，返回一个数组，这个数组包含attrs所列出的属性的所有的 键 - 值对。

```js
_.where = function(obj, attrs) {
  return _.filter(obj, _.matcher(attrs));
};
```

_.findWhere(obj, attrs) 遍历整个obj，返回匹配 properties参数所列出的所有 键 - 值 对的第一个值。

```js
_.findWhere = function(obj, attrs) {
  return _.find(obj, _.matcher(attrs));
};
```

### max 和 min

_.max(obj, [iteratee], [context]) 返回list中的最大值

```js
 _.max = function(obj, iteratee, context) {
  var result = -Infinity, 
    lastComputed = -Infinity,
    value, 
    computed;

  if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object') && obj != null) {
    obj = isArrayLike(obj) ? obj : _.values(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value > result) {
        result = value;
      }
    }
  } else {
    iteratee = cb(iteratee, context);
    _.each(obj, function(v, index, list) {
      computed = iteratee(v, index, list);
      if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
        result = v;
        lastComputed = computed;
      }
    });
  }
  return result;
};
```

这里是实现看起来挺复杂，不要畏惧，一行一行来。 第一段if做了安全检测，防止内存溢出，虽然一般人用不会乱传数字，但xx就不一定了是吧。 让我们继续来断句

```js
if (
  iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object') 
    && obj != null
) {
  ...
}
```

通过条件为 第2行 的 逻辑或 || 成立
1  iteratee == null
2  typeof iteratee == 'number' && typeof obj[0] != 'object'
两句任其一为真即可，1.8.3与1.8.2中唯一的变化就是对obj类型检测提炼了，让其能对对象或数组都能安全迭代，最后返回的 result 即为安全的value值

那么当安全检测未通过时，`_`是这么来处理的，`iteratee = cb(iteratee, context)` 让其提供安全的作用域，然后对传入的obj进行迭代（_.each） computed拿到了迭代对象的作用域，进行自处理，把拿到的值进行安全处理（赋值）

继续断句：

```js
if (
  (computed > lastComputed) || 
  (computed === -Infinity && result === -Infinity)
) {
  ...
}
```
这样看就容易多了，-Infinity限制了所传或最终得到的结果会在js允许的安全范围内

_.min(obj, [iteratee], [context]) 返回list中的最小值。如果传递iteratee参数，iteratee将作为list中每个值的排序依据，如果list为空，将返回-Infinity，所以你可能需要事先用isEmpty检查 list 。

这里和 _.max 差不多就不做过多解释了

```js
_.min = function(obj, iteratee, context) {
  var result = Infinity, lastComputed = Infinity,
      value, computed;
  if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object') && obj != null) {
    obj = isArrayLike(obj) ? obj : _.values(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value < result) {
        result = value;
      }
    }
  } else {
    iteratee = cb(iteratee, context);
    _.each(obj, function(v, index, list) {
      computed = iteratee(v, index, list);
      if (computed < lastComputed || computed === Infinity && result === Infinity) {
        result = v;
        lastComputed = computed;
      }
    });
  }
  return result;
};
```

## 下期预告 Array Functions 

这一部分Collection，集合函数的相关学习就到此为止了，在下一章中，就开始Array Functions的学习了。

## 小结

随着 underscore.js 源码的阅读与学习深入，我们可以了解到很多底层封装的原理与细节。在阅读源码时，不要害怕自己看不懂，理解错，不清楚的地方可以单独拎出来，自己写写或者代码跑起来看看效果以便加深理解。

Collections Function中，其实很多都是对第一章核心函数的一些封装和重复使用，如cb optimizeCb这类用得多的，向外暴露的API又可以让封装的其他API来使用，如 where findWhere就是对filter的运用， pluck是对map的二次封装。