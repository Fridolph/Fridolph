> 读源码是一个提升自己编码和架构的有效方式，明明知道但一直没敢尝试，就算是学习jQuery的源码也是跟着大神的视频，博客一点点填坑的，之前也苦于写的博客没什么技术含量，要不就是自己都知道的，要不就是摘录书中的一些经验，久之反倒没了写博客的兴趣。underscore.js是个优秀的工具库，总代码行也就1600行+ 每天读50行+的速度一个月也能搞定，这么一想完全就不怕了。

多点信心，不怕犯错，多记录和搜索这样利于自己巩固，嗯嗯… 也为后面看Vue、React、Redux源码什么的打点基础，当然那是后话了… 希望这个系列能把坑填完就好

<!-- more -->

---

`注：underscore的 _ 容易看不清，后文提到的 _ 皆用 高亮的 下划线 来替代， 原代码不变`

那么直接开始正文吧~~

## 命名空间管理

最外层是一个IIFE(立即调用函数)，各大框架常用，如jQuery就是典型，这是为了模拟块级作用域，防止污染全局命名空间。具体的好处和由来可以去谷歌一下

```js
((function() {
  // ...
})());
```

## 局部变量声明 14-168行

### 巧妙地变量声明

巧妙地变量声明可以让程序执行地更加效率，关于这些点，在后文中我会力所能及地表达清楚
在说这点前，大家可以看看JS高级程序的第7章函数部分有提到

```js
var root = typeof self == 'object' && self.self === self && self ||
  typeof global == 'object' && global.global === global && global ||
  this ||
  {};
```

### 了解运算符优先级

声明root变量，首先我们要了解JS的运算符优先级，[运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

以下运算符从高到低:

* 16  typeof
* 10  ==、=== 
* 6   逻辑与 &&
* 5   逻辑或 ||

那么我们重新审视这串代码：

```js
var root = 
  ((typeof self == 'object') && (self.self === self) && self) ||
  ((typeof global == 'object') && (global.global === global) && global) ||
  this ||
  {};
```

这样会好理解一些了，把root定义为全局对象，如果不是在浏览器或者Node.js环境中就设为一个空对象

    var previousUnderscore = root._;

previousUnderscore作为全局对象的属性存储，其名为_ ，说不清，但很简单，举个例：

    ((function() {
      var root = window || {};
      var pu = root._;

      pu = {
        'name': 'fri',
        'age': 24
      }

    })());

    console.log(_);

内部作用域的私有变量是pu，但通过root._ 的形式暴露给了全局对象，所以在全局通过 _ 变量就能访问到内部pu对象了

`注：这段代码在严格模式下会报错 ReferenceError: _ is not defined`

```js
var ArrayProto = Array.prototype, 
    ObjProto = Object.prototype;
var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;
var push = ArrayProto.push,
    slice = ArrayProto.slice,
    toString = ObjProto.toString,
    hasOwnProperty = ObjProto.hasOwnProperty;
var nativeIsArray = Array.isArray,
    nativeKeys = Object.keys,
    nativeCreate = Object.create;
```

### 原型链

这里的用处差不多，我就放到一块了，之前我提到过作用域链，而JS是没有类这一说的，其实是通过对象，对象的原型这样一层一层建立起对象的引用关系从而拿到活动对象上的值。

我们看几个原型变量的声明，其实就是简化原型链的查找过程，还是举个例子：

    var arr = [];
    arr.push('a');

声明arr变量为一个空数组，添加一个元素'a'，这个push方法是在arr上的吗？并不是，arr变量上找不到push方法，会搜索arr的原型prototype(arr的constructor指向的对象 -> 这里是Array)。
通过原型链一层层往上找，最终在Array.prototype上找到了push方法，也就是说程序执行 arr.push('a')时，检索到push方法经历了3次搜索即 `arr本身 -> Array对象 -> Array.prototype`
执行效率并不高，所以 var ArrPro = Array.prototype 这样的声明就是减少了搜索过程，从而提升了最终的运行速度

    var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

这里顺便提一下，是对ES6新增的基本数据类型Symbol进行兼容处理

我们接着读

    var Ctor = function(){};    

这里声明了`Ctor`对象 为一个匿名函数，用于代理原型交换

```js
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };
```

### 安全引用

这里为 `下划线` 创建一个安全的引用，这里 `下划线` 是作为一个方法存在，我们结合后面的例子再来说这块

```js
  if (typeof exports != 'undefined' && !exports.nodeType) {
    if (typeof module != 'undefined' && !module.nodeType && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }
```

这里用于支持Node.js，若在浏览器中就让`下划线`成为全局对象
xxx && xxx 这样的语句其实有断句，首先 typeof exports != 'undefinded' 若为false 函数将直接跳过这段语句

    _.VERSION = '1.8.3';

`下划线`的属性， 存储版本号，你看到这里可能很奇怪，之前不是让 `var _ = function() { ... }`了吗，这并不冲突，因为在JS这门语言中一切皆对象，函数也是对象仅此而已`(Function instanceof Object  // true)` `下划线`本身声明为一个匿名函数，但它本身是一个引用类型的数据(对象)，所以继续声明其他属性，或是删除属性也是没有问题的。

68-87行

### optimizeCb 与 函数重载

```js
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      // The 2-parameter case has been omitted only because no current consumers
      // made use of it.
      case null:
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };
```

`optimizeCb`是`下划线`的一个内部函数，该框架内的函数都是以变量的形式来声明，这么做的好处有几点：

1. 避免了不必要的函数声明提升，流程控制性更强
2. 更利于实现内存的回收

那回到代码，`optimizeCb`的作用是什么呢？ 我们分析一下代码段：

if ()

  typeof void 0
  // undefined

若没传入context执行返回传入的func

switch ...

这里有3种模式，(第2种省略了)我们可以理解为函数重载，当然前提是传入合法的`argCount`参数
我们先往下看——

return ...

若没传`argCount`，就返回以下函数

```js
function() {
  return func.apply(context, arguments);
}
```

这里实现了基本的函数重载。（若对这块有很多疑问可以参考下高级程序设计的第7章函数部分）

    var optimizeCb = function(func, context, argCount) {
      ...

      return function() {
        return func.apply(context, arguments);
      }
    }


参考 高级程序设计198页

![活动对象1](/source/img/underscore/01.png)
![活动对象2](/source/img/underscore/02.png)

`optimizeCb`若执行，所传参数，都将作为optimizeCb内部的活动对象，函数执行完毕所返回的匿名函数是一个闭包，它能访问到当前活动对象上的参数，即函数传参。

比如在 case 4 里的代码段

    ...
    return function(accumulator, value, index, collection) {
      return func.call(context, accumulator, value, index, collection);
    };

function(accumulator, value, index, collection) 能访问到上层，传参进行活动对象，执行后返回的func是之前传入，这里调用call方法，以传入的`context`来替换当前的活动对象，并将 accumulator, value, index, collection 作为参数传递给 当前传入的 `context` ，这里有点绕，大家最好自己写点代码在浏览器中测试

```js
var builtinIteratee;

var cb = function(value, context, argCount) {
  if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
  if (value == null) return _.identity;
  if (_.isFunction(value)) return optimizeCb(value, context, argCount);
  if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
  
  return _.property(value);
}

_.iteratee = builtinIteratee = function(value, context) {
  return cb(value, context, Infinity);
};
```

`cb`用于生成可以应用到集合中的每个元素的回调函数，返回想要的结果或标识
iteratee和builtinIteratee一起赋值为一个方法，这里要注意的是 `Infinity`这是一个系统常量

内部作用域是 4个 if语句，若继续执行会 返回 `_.property(value)`(1408行) 这里还是贴一下

```js
_.property = function(path) {
  if (!_.isArray(path)) {
    return shallowProperty(path);
  }
  return function(obj) {
    return deepGet(obj, path);
  };
};
```

我们来具体分析一下：

    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);

也就是说上一句 `_.iterate = builtinIteratee = function(value, context) {...}` 未生效就重新赋值一次，

    if (value == null) return _.identity;

没有传value就默认返回最大

    if (_.isFunction(value)) return optimizeCb(value, context, argCount);

`下划线`自己实现的方法，判断传入对象的引用类型是否为 function 是就用optimizeCb来处理

    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);

同上，若判断成功则用 matcher方法来处理（1429行）

通过这样的判断及调用，可保证我们处理的value值是合法且可控的


## 工具函数

170行+

这一部分就新开一篇文章来写了，希望我的这个部分对你有所帮助，也希望自己能够坚持这样写作，不断提升自己！

