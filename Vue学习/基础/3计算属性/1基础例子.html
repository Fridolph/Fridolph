<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Document</title>
</head>
<body>
  <!-- 
    计算属性
    在模版中绑定表达式是非常便利的，但是它们实际上只用于简单的操作。在模版中放入太多的逻辑会让模版过重且难以维护。 例如：

    <div id="example">
      {{ message.split('').reverse().join('') }}
    </div>

    在这种情况下，模板不再简单和清晰。在实现反向显示 message 之前，你应该确认它。这个问题在你不止一次反向显示 message 的时候变得更加糟糕。

    这就是为什么任何复杂逻辑，你都应当使用计算属性。
   -->
  
  <div id="example">
    <h3>基本例子</h3>
    <p>Original message: "{{ message }}"</p>
    <p>Computed reversed message: "{{ reversedMessage }}"</p>  
  </div>

  <!-- vue.js -->
  <script src="../../vendor/vue.js"></script>
  <script> 
    // 基础例子
    var vm = new Vue({
      el: '#example',
      data: {
        message: 'Hello'
      },
      computed: {
        // a computed getter
        reversedMessage: function() {
          // 'this' points to the vm instance
          return this.message.split('').reverse().join('')
        }
      }
    })
    // 这里我们声明了一个计算属性 reversedMessage
    // 我们提供的函数将用作属性 vm.reversedMessage的getter
    console.log('vm.reversedMessage: ' + vm.reversedMessage);
    
    vm.message = 'YK ai ni '
    console.log('vm.reversedMessage: ' + vm.reversedMessage);

    // 你可以打开浏览器的控制台，修改 vm 。 
    // vm.reversedMessage 的值始终取决于 vm.message 的值。
    
    // 你可以像绑定普通属性一样在模版中绑定计算属性。Vue知道 vm.reversedMessage 依赖于 vm.message， 因此当 vm.message 发生改变时，依赖于 vm.reversedMessage的绑定也会更新。 而且最秒的是我们是声明式地建立这种依赖关系： 计算属性的getter是干净无副作用的，因此也是易于测试和理解的。
    
    /**
     * 计算缓存 vs Methods
     */
  
    
  </script>
</body>
</html>