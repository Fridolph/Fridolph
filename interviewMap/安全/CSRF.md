## CSRF

跨站请求伪造 Cross-site request forgery，是一种挟制用户在当前已登录的web程序上执行非本意的操作的攻击方法。跟XSS相比，XSS利用的是用户对指定网站的信任，CSRF利用的是网站对用户网页浏览器的信任。（CSRF利用用户的登录状态发起恶意请求）

## 如何攻击

假设网站中有一个通过get请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口

```html
<img src="http://example.com/xxx?comment='attack'" />
<!-- 如果接口是post提交，需要用表单提交接口 -->
<form action="http://example.com/xxx?comment='attack'" id="csrf" method="post">
  <input name="comment" value="attack" type="hidden" />
</form>
```

## 如何防御

防御CSRF可以遵循以下几种规则：

1. get请求不对数据进行修改
2. 不让第三方网站访问到用户cookie
3. 阻止第三方网站请求接口
4. 请求时附带验证信息，比如验证码或者token

### SameSite

可以对Cookie设置SameSite属性，该属性设置Cookie不随着跨域请求发送，该属性可以很大程度减少CSRF的攻击，但是该属性目前并不是所有浏览器都兼容


### 验证Referer

对于需要防范CSRF的请求，我们可以通过验证Referer来判断该请求是否为第三方网站发起的

### Token

服务器下发一个随机Token，每次发起请求时将Token携带上，服务器验证Token是否有效

## 密码安全

### 加盐

对于密码存储来说，必然是不能明文存储在数据库中的，否则一旦数据库泄漏，会对用户造成很大的损失。并且不建议只对密码单纯通过加密算法加密，因为存在彩虹表的关系。

通常需要对密码加盐，然后进行几次不同加密算法的加密。

```js
// 加盐也就是给原密码添加字符串，增加原密码长度
sha256(sha1(md5(salt + password + salt)))
```

加盐并不能阻止盗号，只能确保即使玩数据库泄漏，也不会暴露用户的真实密码。一旦攻击者得到了用户的帐号，可以通过暴力破解的方式破解密码。对于该情况，通常使用验证码增加延时或者限制尝试次数的方式。并且一旦用户输入了错误的密码，也不能直接提示用户输错密码，而应该提示帐号或密码错误。

### 前端加密

遇到中间人攻击情况下，前端加密可以避免明文密码被第三方获取。
