## DNS预解析

DNS解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的IP

    <link rel="dns-prefetch" href="//xxx.com" />

## 缓存

缓存对于前端性能优化是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度

通常浏览器缓存策略分为两种：强缓存和协商缓存

### 强缓存

实现强缓存可以通过两种响应头实现：`Expires`和`Cache-Control`。强缓存表示在缓存期间不需要请求，state code 为200

`Expires`是HTTP/1.0 的产物，表示资源在 头信息的时间后过期，需要再次请求。并且Expires受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

`Cache-Control`出现于HTTP/1.1，优先级高于Expires，该属性表示资源会在相对时间后过期，需要再次请求。

### 协商缓存

如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求如果缓存有效会返回304。协商缓存需要客户端和服务端共同实现

`Last-Modified`表示本地文件最后修改时间，`If-Modified-Since`会将Last-Modified的值发送给服务器，询问服务器在该时间后资源是否有更新，有更新的话就会将新的资源发送回来。

但是如果在本地打开缓存文件，就会造成Last-Modified被修改，所以在HTTP/1.1出现了ETag

`ETag`类似于文件指纹，`If-None-Match`会将当前ETag发送给服务器，询问该资源ETag是否变动，有变动就将新资源发送回来，且ETag优先级比Last-Modified高

### 选择合适的缓存策略

对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略。

* 对于某些不需要缓存的资源，可以使用`Cache-Control: no-store`表示该资源不需要缓存
* 对于频繁变动的资源，可以使用`Cache-Control: no-cache`配合ETag使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新
* 对于代码文件来说，通常使用`Cache-Control: max-age=31536000`并配合缓存策略使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件

## 使用HTTP/2.0

因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间。

在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小。

更详细的内容你可以查看 该小节

## 预加载

在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。

预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使用以下代码开启预加载

    <link rel="preload" href="http://example.com">

预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。

## 预渲染

可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染

    <link rel="prerender" href="http://example.com">

预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染
